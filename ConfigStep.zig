const std = @import("std");
const Section = @import("Section.zig");
const Chip = @import("Chip.zig");
const Step = std.build.Step;
const Build = std.Build;
const GeneratedFile = std.build.GeneratedFile;

const ConfigStep = @This();

step: Step,
generated_file: std.build.GeneratedFile,
builder: *Build,
chip: Chip,
sections: []const Section,
hash: [32]u8,

pub fn create(owner: *Build, chip: Chip, sections: []const Section, hash: [32]u8) !*ConfigStep {
    var config = try owner.allocator.create(ConfigStep);
    config.* = ConfigStep{
        .step = Step.init(.{
            .id = .custom,
            .name = "config",
            .owner = owner,
            .makeFn = make,
        }),
        .generated_file = .{
            .step = &config.step,
        },
        .builder = owner,
        .chip = chip,
        .sections = sections,
        .hash = hash,
    };
    return config;
}

fn make(step: *Step) !void {
    const config = @fieldParentPtr(ConfigStep, "step", step);

    const owner = config.step.owner;
    const chip = config.chip;

    // TODO check for existing file and skip regenerating?

    var contents = std.ArrayList(u8).init(owner.allocator);
    defer contents.deinit();

    const writer = contents.writer();

    try writer.writeAll("// This file was auto-generated by microbe\n");

    // TODO consider putting git commit hash in here

    try writer.print("pub const chip_name = \"{}\";\n", .{ std.fmt.fmtSliceEscapeUpper(chip.name) });
    try writer.print("pub const core_name = \"{}\";\n", .{ std.fmt.fmtSliceEscapeUpper(chip.core.name) });

    const target = try std.zig.CrossTarget.zigTriple(chip.core.target, owner.allocator);
    try writer.print("pub const target = \"{s}\";\n", .{ std.fmt.fmtSliceEscapeUpper(target) });

    try writer.writeAll("\npub const regions = struct {\n");
    for (chip.memory_regions) |region| {
        try writer.print("    pub const @\"{s}\" = memSlice({}, {});\n", .{ std.fmt.fmtSliceEscapeUpper(region.name), region.offset, region.length });
    }
    try writer.writeAll("}\n");

    var final_sections = try owner.allocator.alloc(?usize, chip.memory_regions.len);
    @memset(final_sections, null);
    for (config.sections, 0..) |section, i| {
        if (section.ram_region orelse section.rom_region) |region_name| {
            for (chip.memory_regions, 0..) |region, r| {
                if (std.mem.eql(u8, region_name, region.name)) {
                    final_sections[r] = i;
                }
            }
        }
    }

    for (config.sections, 0..) |section, i| {
        var load = false;
        var start = false;
        var min = false;
        var end = false;
        for (final_sections) |section_index| {
            if (section_index == i) {
                min = true;
                end = true;
            }
        }
        if (section.ram_region) |_| {
            if (section.rom_region) |_| {
                load = true;
                start = true;
                end = true;
            } else if (section.init_value) |_| {
                start = true;
                end = true;
            }
        }
        if (load) try writer.print("extern const _{s}_load: anyopaque;\n", .{ section.name });
        if (start) try writer.print("extern var _{s}_start: anyopaque;\n", .{ section.name });
        if (min) try writer.print("extern const _{s}_min: anyopaque;\n", .{ section.name });
        if (end) try writer.print("extern const _{s}_end: anyopaque;\n", .{ section.name });
    }

    try writer.writeAll(
        \\pub fn init() void {
        \\
    );

    for (config.sections, 0..) |section, i| {
        for (final_sections) |section_index| {
            if (section_index == i) {
                try writer.print(
                    \\    if (@ptrToInt(&_{s}_min) > @ptrToInt(&_{s}_end)) @panic("OOM");
                    \\
                , .{ section.name, section.name });
            }
        }
        if (section.ram_region) |_| {
            if (section.rom_region) |_| {
                try writer.print(
                    \\    {{
                    \\        const load = @ptrCast([*]const u8, &_{s}_load);
                    \\        const start = @ptrCast([*]u8, &_{s}_start);
                    \\        const end = @ptrCast([*]const u8, &_{s}_end);
                    \\        const len = @ptrToInt(end) - @ptrToInt(start);
                    \\        @memcpy(start, load, len);
                    \\    }}
                    \\
                , .{ section.name, section.name, section.name });
            } else if (section.init_value) |v| {
                try writer.print(
                    \\    {{
                    \\        const start = @ptrCast([*]u8, &_{s}_start);
                    \\        const end = @ptrCast([*]const u8, &_{s}_end);
                    \\        const len = @ptrToInt(end) - @ptrToInt(start);
                    \\        @memset(start, {}, len);
                    \\    }}
                    \\
                , .{ section.name, section.name, v });
            }
        }
    }

    try writer.writeAll(
        \\}
        \\
        \\
    );

    try writer.writeAll(
        \\fn memSlice(comptime begin: u32, comptime len: u32) []u8 {
        \\    var slice: []u8 = undefined;
        \\    slice.ptr = @intToPtr(begin);
        \\    slice.len = len;
        \\    return slice;
        \\}
        \\
    );

    const dir_path = try owner.cache_root.join(owner.allocator, &.{
        "microbe",
        chip.name,
        chip.core.name,
    });

    var dir = try owner.cache_root.handle.makeOpenPath(dir_path, .{});
    defer dir.close();

    const filename = try std.fmt.allocPrint(owner.allocator, "{s}.zig", .{ &config.hash });
    const file = try dir.createFile(filename, .{});
    defer file.close();

    try file.writeAll(contents.items);
    const full_path = owner.pathJoin(&.{ dir_path, filename });
    config.generated_file.path = full_path;
}
