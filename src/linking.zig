const std = @import("std");
const Step = std.build.Step;
const Builder = std.build.Builder;
const GeneratedFile = std.build.GeneratedFile;
const build_config = @import("build_config.zig");
const Section = build_config.Section;
const Chip = build_config.chips.Chip;

pub const LinkerScriptStep = struct {
    step: Step,
    generated_file: std.build.GeneratedFile,
    builder: *Builder,
    chip: Chip,
    sections: []Section,

    pub fn create(builder: *Builder, chip: Chip, sections: []const Section, hash: []const u8) !*LinkerScriptStep {
        const path = try std.fmt.allocPrint(builder.allocator, "zig-cache/microbe/{s}.ld", .{ hash });
        try std.fs.cwd().makePath(std.fs.path.dirname(path).?);

        var ret = try builder.allocator.create(LinkerScriptStep);
        ret.* = LinkerScriptStep{
            .step = Step.init(.custom, "linkerscript", builder.allocator, make),
            .generated_file = .{
                .step = &ret.step,
                .path = path,
            },
            .builder = builder,
            .chip = chip,
            .sections = try builder.allocator.dupe(Section, sections),
        };
        return ret;
    }

    fn findMemoryRegionIndex(region_name: []const u8, chip: Chip) !usize {
        for (chip.memory_regions) |region, i| {
            if (std.mem.eql(u8, region_name, region.name)) {
                return i;
            }
        }
        std.log.err("chip {s} does not have a memory region named {any}", .{ chip.name, region_name });
        return error.MissingMemoryRegion;
    }

    fn make(step: *Step) !void {
        const linkerscript = @fieldParentPtr(LinkerScriptStep, "step", step);
        const file = try std.fs.cwd().createFile(linkerscript.generated_file.path.?, .{});
        defer file.close();

        const chip = linkerscript.chip;
        const target = chip.core.target;
        if (target.cpu_arch == null) {
            std.log.err("target does not have 'cpu_arch'", .{});
            return error.NoCpuArch;
        }

        const writer = file.writer();
        try writer.print(
            \\/*
            \\ * This file was auto-generated by microbe
            \\ *
            \\ * Target CPU:  {s}
            \\ * Target Chip: {s}
            \\ */
            \\ENTRY(microbe_main);
            \\
            \\MEMORY
            \\{{
            \\
        , .{ chip.core.name, chip.name });

        for (chip.memory_regions) |region| {
            try writer.print("  {s} (", .{ region.name });
            if (region.access.contains(.readable)) try writer.writeAll("r");
            if (region.access.contains(.writable)) try writer.writeAll("w");
            if (region.access.contains(.executable)) try writer.writeAll("x");
            try writer.print(") : ORIGIN = 0x{X:0>8}, LENGTH = 0x{X:0>8}\n", .{ region.offset, region.length });
        }

        var final_sections = try linkerscript.builder.allocator.alloc(?usize, chip.memory_regions.len);
        for (final_sections) |*section_index| {
            section_index.* = null;
        }
        for (linkerscript.sections) |section, i| {
            if (section.ram_region) |ram| {
                var r = try findMemoryRegionIndex(ram, chip);
                final_sections[r] = i;
                if (section.rom_region) |rom| {
                    // just make sure the rom region exists
                    _ = try findMemoryRegionIndex(rom, chip);
                }
            } else if (section.rom_region) |rom| {
                var r = try findMemoryRegionIndex(rom, chip);
                final_sections[r] = i;
            }
        }

        try writer.writeAll(
            \\}
            \\
            \\SECTIONS
            \\{
            \\
        );

        for (linkerscript.sections) |section, section_index| {
            
            if (section.ram_region) |ram| {
                const r = try findMemoryRegionIndex(ram, chip);
                const is_final_section = final_sections[r] == section_index;
                if (section.rom_region) |rom| {
                    try writeSectionLoad(writer, section, is_final_section, ram, rom);
                } else {
                    try writeSectionRam(writer, section, is_final_section, ram);
                }
            } else if (section.rom_region) |rom| {
                const r = try findMemoryRegionIndex(rom, chip);
                const is_final_section = final_sections[r] == section_index;
                try writeSectionRom(writer, section, is_final_section, rom);
            } else {
                std.log.err("Section {s} must be assigned to a ROM or RAM memory range, or both!", .{ section.name });
                return error.InvalidSection;
            }
        }

        try writer.writeAll(
            \\}
            \\
        );

        for (chip.memory_regions) |region, region_index| {
            if (final_sections[region_index]) |section_index| {
                var section = linkerscript.sections[section_index];
                try writer.print(
                    \\_{s}_end = ORIGIN({s}) + LENGTH({s});
                    \\
                , .{ section.name, region.name, region.name });
            }
        }
    }

    fn writeSectionRam(writer: anytype, section: Section, is_final_section: bool, region_name: []const u8) !void {
        try writer.print(
            \\  .{s} (NOLOAD) :
            \\  {{
            \\
        , .{ section.name });
        try writeSectionContents(writer, section, is_final_section);
        try writer.print(
            \\  }} > {s}
            \\
            \\
        , .{ region_name });
    }

    fn writeSectionRom(writer: anytype, section: Section, is_final_section: bool, region_name: []const u8) !void {
        try writer.print(
            \\  .{s} :
            \\  {{
            \\
        , .{ section.name });
        try writeSectionContents(writer, section, is_final_section);
        try writer.print(
            \\  }} > {s}
            \\
            \\
        , .{ region_name });
    }

    fn writeSectionLoad(writer: anytype, section: Section, is_final_section: bool, ram_region: []const u8, rom_region: []const u8) !void {
        try writer.print(
            \\  .{s} :
            \\  {{
            \\
        , .{ section.name });
        try writeSectionContents(writer, section, is_final_section);
        try writer.print(
            \\  }} > {s} AT > {s}
            \\  _{s}_load = LOADADDR(.{s});
            \\
            \\
        , .{ ram_region, rom_region, section.name, section.name });
    }

    fn writeSectionContents(writer: anytype, section: Section, is_final_section: bool) !void {
        var buf: [64]u8 = undefined;
        var clean_name = try std.fmt.bufPrint(&buf, "{s}", .{ section.name });
        for (clean_name) |*c| {
            switch (c.*) {
                'a'...'z', 'A'...'Z', '0'...'9' => {},
                else => {
                    c.* = '_';
                },
            }
        }
        if (section.start_alignment_bytes) |alignment| {
            try writer.print(
                \\    . = ALIGN({});
                \\
            , .{ alignment });
        }
        try writer.print(
            \\    _{s}_start = .;
            \\
        , .{ clean_name });
        for (section.contents) |entry| {
            try writer.print(
                \\    {s}
                \\
            , .{ entry });
        }
        if (section.end_alignment_bytes) |alignment| {
            try writer.print(
                \\    . = ALIGN({});
                \\
            , .{ alignment });
        }
        if (is_final_section) {
            try writer.print(
                \\    _{s}_min = .;
                \\
            , .{ clean_name });
        } else {
            try writer.print(
                \\    _{s}_end = .;
                \\
            , .{ clean_name });
        }
    }
};

