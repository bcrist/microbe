step: Step,
output_file: GeneratedFile,
chip: Chip,
sections: []const Section,
runtime_resource_validation: bool,

pub fn create(owner: *Build, chip: Chip, sections: []const Section, enable_runtime_resource_validation: bool) *Config_Step {
    var self = owner.allocator.create(Config_Step) catch @panic("OOM");
    self.* = Config_Step{
        .step = Step.init(.{
            .id = .custom,
            .name = "config",
            .owner = owner,
            .makeFn = make,
        }),
        .output_file = .{
            .step = &self.step,
        },
        .chip = chip,
        .sections = sections,
        .runtime_resource_validation = enable_runtime_resource_validation,
    };
    return self;
}

pub fn get_output(self: *const Config_Step) std.Build.LazyPath {
    return .{ .generated = &self.output_file };
}

fn make(step: *Step, progress: *std.Progress.Node) !void {
    _ = progress;

    const b = step.owner;
    const self = @fieldParentPtr(Config_Step, "step", step);
    const chip = self.chip;

    var man = b.cache.obtain();
    defer man.deinit();

    // Random bytes to make hash unique. Change this if implementation is modified.
    man.hash.add(@as(u32, 0x212b_4d27));

    hash.add_chip_and_sections(&man.hash, chip, self.sections);

    if (try step.cacheHit(&man)) {
        // Cache hit, skip regenerating file.
        const digest = man.final();
        self.output_file.path = try b.cache_root.join(b.allocator, &.{
            "microbe",
            &digest,
            "config.zig",
        });
        return;
    }

    const digest = man.final();
    self.output_file.path = try b.cache_root.join(b.allocator, &.{
        "microbe",
        &digest,
        "config.zig",
    });
    const cache_dir = "microbe" ++ std.fs.path.sep_str ++ digest;
    b.cache_root.handle.makePath(cache_dir) catch |err| {
        return step.fail("unable to make path {s}: {s}", .{ cache_dir, @errorName(err) });
    };

    var contents = std.ArrayList(u8).init(b.allocator);
    defer contents.deinit();

    const writer = contents.writer();

    try writer.writeAll(
        \\// This file was auto-generated by microbe\n");
        \\const std = @import("std");
        \\const chip = @import("chip");
        \\
        \\
    );

    // TODO consider putting git commit hash in here
    try writer.print(
        \\pub const chip_name = "{}";
        \\pub const core_name = "{}";
        \\
        \\pub const target = "{s}";
        \\
        \\pub const runtime_resource_validation = {};
        \\
    , .{
        std.fmt.fmtSliceEscapeUpper(chip.name),
        std.fmt.fmtSliceEscapeUpper(chip.core.name),
        std.fmt.fmtSliceEscapeUpper(try std.zig.CrossTarget.zigTriple(chip.core.target, b.allocator)),
        self.runtime_resource_validation,
    });

    try writer.writeAll(
        \\
        \\comptime {
        \\    if (!std.mem.startsWith(u8, chip_name, chip.base_name)) {
        \\        @compileError("Chip module's name does not match root configuration!");
        \\    }
        \\
        \\    if (!std.mem.eql(u8, core_name, chip.core_name)) {
        \\        @compileError("Core module's name does not match root configuration!");
        \\    }
        \\}
        \\
        \\
    );

    for (chip.extra_config) |option| {
        if (option.escape) {
            try writer.print("pub const {s} = \"{s}\";\n", .{ std.zig.fmtId(option.name), std.fmt.fmtSliceEscapeUpper(option.value) });
        } else {
            try writer.print("pub const {s} = {s};\n", .{ std.zig.fmtId(option.name), option.value });
        }
    }

    try writer.writeAll("\npub const regions = struct {\n");
    for (chip.memory_regions) |region| {
        try writer.print("    pub const @\"{s}\" = mem_slice(0x{X}, 0x{X});\n", .{ std.fmt.fmtSliceEscapeUpper(region.name), region.offset, region.length });
    }
    try writer.writeAll(
        \\};
        \\
        \\// TODO switch to anyopaque when https://github.com/ziglang/zig/issues/16627 is fixed
        \\
    );

    var final_sections = try b.allocator.alloc(?usize, chip.memory_regions.len);
    @memset(final_sections, null);
    for (self.sections, 0..) |section, i| {
        if (section.ram_region orelse section.rom_region) |region_name| {
            for (chip.memory_regions, 0..) |region, r| {
                if (std.mem.eql(u8, region_name, region.name)) {
                    final_sections[r] = i;
                }
            }
        }
    }

    for (self.sections, 0..) |section, i| {
        var load = false;
        var start = false;
        var min = false;
        var end = false;
        for (final_sections) |section_index| {
            if (section_index == i) {
                min = true;
                end = true;
            }
        }
        if (section.ram_region) |_| {
            if (section.rom_region) |_| {
                load = true;
                start = true;
                end = true;
            } else if (section.init_value) |_| {
                start = true;
                end = true;
            }
        }
        if (load) try writer.print("extern const _{s}_load: u8;\n", .{ section.name });
        if (start) try writer.print("extern var _{s}_start: u8;\n", .{ section.name });
        if (min) try writer.print("extern const _{s}_min: u8;\n", .{ section.name });
        if (end) try writer.print("extern const _{s}_end: u8;\n", .{ section.name });
    }

    try writer.writeAll(
        \\
        \\pub fn init_ram() callconv(.C) void {
        \\    @setCold(true);
        \\
    );

    for (self.sections) |section| {
        if (section.skip_init) continue;

        if (section.ram_region) |_| {
            if (section.rom_region) |_| {
                try writer.print(
                    \\    {{
                    \\        const load: [*]const u8 = @ptrCast(&_{s}_load);
                    \\        const start: [*]u8 = @ptrCast(&_{s}_start);
                    \\        const end: [*]const u8 = @ptrCast(&_{s}_end);
                    \\        const len = @intFromPtr(end) - @intFromPtr(start);
                    \\        @memcpy(start[0..len], load);
                    \\    }}
                    \\
                , .{ section.name, section.name, section.name });
            } else if (section.init_value) |v| {
                try writer.print(
                    \\    {{
                    \\        const start: [*]u8 = @ptrCast(&_{s}_start);
                    \\        const end: [*]const u8 = @ptrCast(&_{s}_end);
                    \\        const len = @intFromPtr(end) - @intFromPtr(start);
                    \\        @memset(start[0..len], {});
                    \\    }}
                    \\
                , .{ section.name, section.name, v });
            }
        }
    }

    try writer.writeAll(
        \\}
        \\
        \\
    );

    try writer.writeAll(
        \\fn mem_slice(comptime begin: u32, comptime len: u32) []u8 {
        \\    var slice: []u8 = undefined;
        \\    slice.ptr = @ptrFromInt(begin);
        \\    slice.len = len;
        \\    return slice;
        \\}
        \\
    );

    var file = try b.cache_root.handle.createFile(self.output_file.getPath(), .{});
    defer file.close();

    try file.writeAll(contents.items);
    try man.writeManifest();
}

const Config_Step = @This();
const Section = @import("Section.zig");
const Chip = @import("Chip.zig");
const hash = @import("hash.zig");
const GeneratedFile = Build.GeneratedFile;
const Step = Build.Step;
const Build = std.Build;
const std = @import("std");
